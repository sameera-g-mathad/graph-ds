import { App } from './app';
import { Graph } from './graph';
import type { algo, graphFlavor, shape, styleType } from './interface';

// Get the body of the page to set a color
const body = document.getElementById('body') as HTMLBodyElement;
// Get the algorithm name from the html element.
// Ex: 'bfs', 'dfs', 'ucs'
const algorithm = document.getElementById('algo') as HTMLSelectElement;

// Get the graph type supported in the application.
// ex: 'regular', 'maze', 'weighted'.
const graphType = document.getElementById('graph') as HTMLSelectElement;

// Used to generate the shape of the nodes.
const shape = document.getElementById('shape') as HTMLSelectElement;

// Used to set the cell width of each node in the graph.
// Allowed range: [15, 30]
const cellInput = document.getElementById('cellWidth') as HTMLInputElement;

// Used to regenerate the graph for randomness.
const regenerate = document.getElementById('regen') as HTMLButtonElement;

// Used to start the traversal.
const start = document.getElementById('start') as HTMLButtonElement;

// Used to distinguish between drag and click. If this
// doesn't work as needed, then reassignments to this
// variable has to be removed.
let isDragging: boolean = false;

////////////////////////////////////////////////////////////////////////////
// This section is used to add styling.
// Themes generated by Claude.
const styling: { [key: string]: { [key in styleType]: string } } = {
  // Warm Sunset Theme
  sunset_glow: {
    bg: '#ffeaa7', // Warm cream background
    nodeColor: 'white', // Clean white nodes
    source: '#fd79a8', // Bright pink source
    destination: '#e84393', // Deep pink destination
    path: '#fdcb6e', // Golden yellow path
    text: '#2d3436', // Dark gray text
    visited: '#fab1a0', // Soft coral visited
    mix: '#2d3436', // Dark gray mix
  },

  // Forest Vibes Theme
  forest_vibes: {
    bg: '#a8e6cf', // Mint green background
    nodeColor: 'white', // White nodes
    source: '#ff6b6b', // Coral red source
    destination: '#4ecdc4', // Turquoise destination
    path: '#ffe66d', // Sunny yellow path
    text: '#2d3436', // Dark text
    visited: '#95e1d3', // Soft mint visited
    mix: '#2d3436', // Dark mix
  },

  // Lavender Dreams Theme
  lavender_dreams: {
    bg: '#e8daef', // Soft lavender background
    nodeColor: 'white', // White nodes
    source: '#8e44ad', // Deep purple source
    destination: '#3498db', // Blue destination
    path: '#f39c12', // Orange path
    text: '#2c3e50', // Navy text
    visited: '#d7bde2', // Light purple visited
    mix: '#2c3e50', // Navy mix
  },

  // Coral Reef Theme
  coral_reef: {
    bg: '#ffccbc', // Peach background
    nodeColor: 'white', // White nodes
    source: '#ff7043', // Orange-red source
    destination: '#26a69a', // Teal destination
    path: '#ffeb3b', // Bright yellow path
    text: '#37474f', // Blue-gray text
    visited: '#ffab91', // Light coral visited
    mix: '#37474f', // Blue-gray mix
  },

  // Cosmic Purple Theme
  cosmic_purple: {
    bg: '#d1c4e9', // Light purple background
    nodeColor: 'white', // White nodes
    source: '#7b1fa2', // Deep purple source
    destination: '#e91e63', // Pink destination
    path: '#ffc107', // Amber path
    text: '#263238', // Dark blue-gray text
    visited: '#ce93d8', // Medium purple visited
    mix: '#263238', // Dark blue-gray mix
  },

  // Fresh Mint Theme
  fresh_mint: {
    bg: '#c8e6c9', // Light green background
    nodeColor: 'white', // White nodes
    source: '#e53935', // Red source
    destination: '#1e88e5', // Blue destination
    path: '#ffb300', // Orange path
    text: '#1b5e20', // Dark green text
    visited: '#a5d6a7', // Soft green visited
    mix: '#1b5e20', // Dark green mix
  },

  // Retro Vibes Theme
  retro_vibes: {
    bg: '#ffecb3', // Cream background
    nodeColor: 'white', // White nodes
    source: '#d32f2f', // Classic red source
    destination: '#1976d2', // Classic blue destination
    path: '#ff9800', // Orange path
    text: '#424242', // Gray text
    visited: '#ffcc02', // Golden visited
    mix: '#424242', // Gray mix
  },
  // Tropical Theme
  tropical: {
    bg: '#fff9c4', // Light yellow background
    nodeColor: 'white', // White nodes
    source: '#ff4081', // Hot pink source
    destination: '#00bcd4', // Cyan destination
    path: '#4caf50', // Green path
    text: '#2e7d32', // Dark green text
    visited: '#ffcc80', // Light orange visited
    mix: '#2e7d32', // Dark green mix
  },
};

const styles = [
  'sunset_glow',
  'forest_vibes',
  'lavender_dreams',
  'coral_reef',
  'cosmic_purple',
  'fresh_mint',
  'retro_vibes',
  'tropical',
];
const randomStyle = Math.floor(Math.random() * styles.length);

body.style.backgroundColor = styling[styles[randomStyle]]['bg'];

const assignColor = (
  element: HTMLSelectElement | HTMLInputElement | HTMLButtonElement,
  color: string,
  mixColor: string
) => {
  element.style.backgroundColor = color;
  element.style.color = `color-mix(in srgb, ${color} 60%, white 10%,  ${mixColor})`;
};

assignColor(
  algorithm,
  styling[styles[randomStyle]]['source'],
  styling[styles[randomStyle]]['mix']
);

assignColor(
  graphType,
  styling[styles[randomStyle]]['destination'],
  styling[styles[randomStyle]]['mix']
);

assignColor(
  cellInput,
  styling[styles[randomStyle]]['source'],
  styling[styles[randomStyle]]['mix']
);

assignColor(
  shape,
  styling[styles[randomStyle]]['path'],
  styling[styles[randomStyle]]['mix']
);

assignColor(
  regenerate,
  styling[styles[randomStyle]]['source'],
  styling[styles[randomStyle]]['mix']
);

assignColor(
  start,
  styling[styles[randomStyle]]['destination'],
  styling[styles[randomStyle]]['mix']
);

////////////////////////////////////////////////////////////////////////////
// The singleton app, used to hold all the
// settings of the application.
const app = App.getInstance();

// declare a graph variable to hold reference later.
let graph: Graph;

// method called to set the app settings,
// create a graph instance.
// Is called when graphType changes or regenerate button
// is clicked and when the window is loaded or resized.
const init = () => {
  // set cell width.
  isDragging = false;
  app.setCellWidth(parseInt(cellInput.value));

  // To set Dimensions. Adjusts the canvas window
  // dimensions according to the size of the website.
  // Works well when resizing.
  app.setDimensions();
  app.setAlgo(algorithm.value as algo);
  app.setShape(shape.value as shape);
  app.setColor(styling[styles[randomStyle]]);
  graph = Graph.requestGraph(graphType.value as graphFlavor);
};

// Sets the source and destination points in the
// graph.
app.canvas.addEventListener('click', (event) => {
  if (isDragging) return;
  // Gets the boundary of the canvas
  let bounds = app.canvas.getBoundingClientRect();
  let cellWidth = app.getCellWidth();
  // Subtract the window point_x with the relative canvas point
  // to find where the click happened inside the graph/canvas.
  // Dividing by cellWidth, gives the cell dimensions or exact
  // cell that was clicked within the graph/canvas.
  let col = Math.floor((event.clientX - bounds.x) / cellWidth);
  let row = Math.floor((event.clientY - bounds.y) / cellWidth);

  // This check is added to counter valid boxes,
  // expecially in case of maze graph. Since walls
  // cannot be considered a start or a destination.
  if (graph.isValid(row, col)) {
    // check if source exists.
    if (!graph.sourceExists) {
      graph.graphSource(row, col);
    }
    // check if destination exists.
    else if (!graph.destinationExists) {
      graph.graphDestination(row, col);
    }
    // Clears the previous source and destination value
    // when user clicks more than twice to reset values.
    else {
      graph.clearSrcAndDest();
    }
  }
});

// To add walls in the graph if the graphType is
// 'regular' and 'weighted'. To set the wall, first
// source and destination has to be set up. Added it
// as a experimental feature to try. This works when
// the user clicks the mouse and starts to move
// around the graph.
app.canvas.addEventListener('mousedown', () => {
  if (
    graph.sourceExists &&
    graph.destinationExists &&
    (graph.graphType === 'regular' || graph.graphType === 'weighted')
  ) {
    // start collecting nodes to block
    const mousemove = (event: MouseEvent) => {
      isDragging = true;
      // Gets the boundary of the canvas
      let bounds = app.canvas.getBoundingClientRect();
      let cellWidth = app.getCellWidth();
      // Subtract the window point_x with the relative canvas point
      // to find where the click happened inside the graph/canvas.
      // Dividing by cellWidth, gives the cell dimensions or exact
      // cell that was clicked within the graph/canvas.
      let col = Math.floor((event.clientX - bounds.x) / cellWidth);
      let row = Math.floor((event.clientY - bounds.y) / cellWidth);

      // block node
      graph.blockNode(row, col);
    };
    // stop collecting nodes by removing listeners.
    const mouseup = () => {
      app.canvas.removeEventListener('mousemove', mousemove);
      app.canvas.removeEventListener('mouseup', mouseup);
    };
    app.canvas.addEventListener('mousemove', mousemove);
    app.canvas.addEventListener('mouseup', mouseup);
    isDragging = false;
  }
});

// Gets the updated selected algorithm.
algorithm.addEventListener('change', () => {
  isDragging = false;
  app.setAlgo(algorithm.value as algo);
});

// Gets the updated selected graph type.
graphType.addEventListener('change', () => {
  isDragging = false;
  graph = Graph.requestGraph(graphType.value as graphFlavor);
});

// Gets the updated selected shape.
shape.addEventListener('change', () => {
  isDragging = false;
  app.setShape(shape.value as shape);
});

// Gets the cell width to be used in the graph.
// Since the input returns a string, proper
// type checks are placed and also the range
// is maintained within [15, 30]
cellInput.addEventListener('change', () => {
  let newValue = parseInt(cellInput.value);
  if (Number.isNaN(newValue)) {
    cellInput.value = '15';
  } else if (newValue < 15) {
    cellInput.value = '20';
  } else if (newValue > 40) {
    cellInput.value = '40';
  }
});

// Regerates the entire graph.
regenerate.addEventListener('click', init);

// Starts the graph traversal.
start.addEventListener('click', () => graph.traverse());

// Start of the application
window.addEventListener('load', init);

// When user resizes the window.
window.addEventListener('resize', init);
